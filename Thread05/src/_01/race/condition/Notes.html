Şimdi asagidaki kucuk kod ornegimiz uzerinden kotu bir senaryo dusunelim ;

public class Counter {
    private  long count = 0;
    public void add(long value){
        this.count = this.count + value;
    }
}
A ve B olmak uzere 2 tane thread oldugunu dusunelim. Burada value degeri 2 ve 3 olarak deger geldigini varsayalim;

this.count = 0 degerine sahiptir.
A threadi register(hafiza)’dan degeri okur. (this.count = 0)
B threadi register(hafiza)’dan degeri okur. (this.count = 0)
A thread’i 2 degerini ekler.
A thread’i 2 degerini register’a yazar. this.count = 2 dir.
B thread’i zaten degeri okumustu bu noktada 3 degeri ekler.
B thread’i register’a 3 degerini yazar. this.count = 3 oldu.

this.count degerini 5 beklerken 3 oldu ! Peki neden boyle oldu ?

Birden fazla thread , “ayni kaynaga” ulastiginda (read) problem olmaz.
Problem teskil edecek nokta ; birden fazla thread “ayni kaynaga”(instance variable), “ayni obje referansi” uzerinden ulasip degistirmeye calistiginda(write) ortaya cikabilir. Bu probleme Race Condition adi verilir. Local degiskenerin durumu ve instance degiskenler yazinin sonunda tekrar ele alinacaktir.

Running durumunda bir thread , Thread Scheduler tarafindan heran calismasi runnable duruma gecebilir bir baska thread running duruma gecebilir.
Bu nedenle hangi thread’in “paylasilan kaynaga” ulasmaya calistigini bilemeyiz.

Thread Interference(girisim/karisma/karisim) , ayni ‘data’ uzerinde farkli threadler araliklarla(interleave) calistigi durumda ortaya cikabilir.