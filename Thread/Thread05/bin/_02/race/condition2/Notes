Instance degiskenler obje ile birlikte heap’te yasarlar. Bu nedenle eger birden fazla thread “ayni obje” refansi uzerinden bir metot cagirirsa ve bu metot icerisinde 
instance degiskenin degeri degistirilirse bu durumda bu metot thread-safe degildir.

public class NotThreadSafe {
	StringBuilder builder = new StringBuilder();

	public void add(String text) {
		this.builder.append(text);
	}

	private long count = 0;

	public void add(long value) {
		this.count = this.count + value;
	}

}

Birden fazla thread add metodunu “ayni NotThreadSafe objesi” uzerinden ayni anda/es zamanli olarak/simultaneously cagirirsa burada race condition durumu ortaya cikar.

public class NotThreadSafe {
	StringBuilder builder = new StringBuilder();

	public static void main(String[] args) {
		NotThreadSafe sharedInstance = new NotThreadSafe();

		new Thread(new MyRunnable(sharedInstance)).start();
		new Thread(new MyRunnable(sharedInstance)).start();

	}

	public void add(String text) {
		this.builder.append(text);
	}

}

class MyRunnable implements Runnable {
	NotThreadSafe instance = null;

	public MyRunnable(NotThreadSafe instance) {
		this.instance = instance;
	}

	public void run() {
		this.instance.add("some text");
	}
}
Bununla birlikte birden fazla thread add metodunu “farkli NotThreadSafe “ objesi uzerinden ayni anda/es zamanli olarak/simultaneously cagirirsa burada race condition durumu ortaya cikmaz.

....
	public static void main(String[] args) {
		NotThreadSafe sharedInstance1 = new NotThreadSafe();
		NotThreadSafe sharedInstance2 = new NotThreadSafe();

		new Thread(new MyRunnable(sharedInstance1)).start();
		new Thread(new MyRunnable(sharedInstance2)).start();
	}
....
Burada her thread kendi NotThreadSafe objesine sahiptir. NotThreadSafe objesi paylasilmadigi icin thread’lerin birbirine mudahale etmesi/karismasi(interfere) mumkun degildir. Burada race condition durumu ortaya cikmayacaktir.