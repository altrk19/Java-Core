Java’da “thread” 2 anlama gelmektedir;

java.lang.Thread sinifinin bir ornegi/instance/objesi
calisan bir is parcacigi(lightweight process)
java.lang.Thread sinifinin bir orgnegi/instance Java’da bildigimiz diger objeler gibidir. Benzer sekilde degiskenleri, metotlari vardir , Heap’te yasarlar. 
Java’da sinif hiyerarsisinin tepesinde java.lang.Object sinifi bulunmaktadir. Her sinif varsayilan olarak Object sinifini kalitmaktadir dolayisiyla 
Thread IS-A Object onermesi dogrudur.

“calisan is parcacigi” olarak anlami ; kendi “Stack” alanina sahip individual(bireysel/ayri/ozgun) lightweigh process anlamina gelmektedir.

Process kavrami , Isletim Sitemi acisindan genel olarak calisan program ve uygulamalar anlamina gelir.  Word, paint, Eclipse gibi. Bir process birden fazla 
thread/is parcacigi icerebilir.

Java’da her thread’e karsilik bir stack calisir. Eger siz yeni thread’ler olusturmasaniz bile bir thread calisacaktir. main() metodu “main” ismine sahip bir 
thread’i calistirir. Eger kendimiz yeni thread’ler olusturursak bu durumda bu tread’ler farkli farkli Stacklerde calisacaktir.

JVM(Java Virtual Machine), mini bir Isletim Sistemi (OS) gibi calisir ve thread’lerin program/zaman yonetimi(schedule) JVM in kontrolu altindadir.Soz konusu 
Thread oldugunda “garanti” , “kesin” bir durum soz konusu degildir. Farkli JVM’ler farkli thread schedule mekanizmasi kullanabilirler.

java.lang.Thread sinifini inceldigimizde onemli olan(sinavda sorumlu oldugumuz) su metotlari gorebiliriz. Bunlari ilerleyen yazilarda inceleyecegiz.
start()
yield()
sleep()
run()

Thread konusunda olayin action kismi run() metodudur.Yeni bir thread’te bir is(job) yapmak istiyorsaniz bunu run() metodu icerisinde tanimlayabilirsiniz. 
Yeni bir stack cagrilmasina run() metodu baslatir.

Yeni bir “is parcacigi/thread” olusturmak icin 2 yaklasim vardir ;

java.lang.Thread sinifini kalitmak
java.lang.Runnable arabirimini uygulamak
java.lang.Thread sinifini kalitmak en kolay yoludur fakat genel olarak guzel bir Object Oriented yaklasimi degildir.

Bir Car sinifi Thread sinifini kalittigi zaman Car IS-A Thread onermesi dogru olur. Subclass/alt sinif , super class/ust sinifin daha ozellesmis hali olmalidir. 
Eger daha ozellesmis bir Thread yapisi alt sinifta yapilmayacaksa kalitmak iyi bir OO tercihi olmayacaktir.
Ikinci olarak, Java’da bir sinif sadece bir sinifi kalitabilir. Thread sinifini kalittigimiz zaman kotayi doldurmus oluruz.

Bunun yerine genel olarak java.lang.Runnable arabirimini kullanmak daha dogru bir yaklasim olacaktir.

Bir sinif birden fazla arabirimi uygulayabilir dolayisiyla herhangi bir kisita neden olmaz.
Arabirimler sinif hiyerarsisinde yer almazlar ve sinif hiyerarsisinden bagimsiz olarak herhangi bir sinif tarafindan uygulanabilir.
extending java.lang.Thread ( Thread sinifini kalitmak)
Bir thread(is parcacigi) tanimlamak/define icin ;

java.lang.Thread sinifini kalit.
run() metodunu override et
public class CoolThread extends Thread {

	@Override
	public void run() {
		System.out.println("The job is starting!");
	}

}

Override edilmis run metoduna dikkat edelim.Bununla birlikte Overloaded run metotlari da tanimlayabiliriz fakat overloaded run metotlari metotlari kendimiz 
cagirmadiktan sonra Thread sinifi tarafindan bu metotlar gormezden gelinir(ignore). Thread sinifinin dikkate aldigi metot parametre almayan run() metodudur 
ve bu metodun cagrilmasi yeni bir stack olusmasini saglar.

Kisacasi ;

Sadece parametre almayan run() metodu Thread sinifi tarafindan otomatik cagrilir.
run metodu yeni bir stack olusmasini saglar.
implementing java.lang.Runnable (Runnable arabirimini uygulamak)
java.lang.Runnable arabirimini inceledigimizde sadece run metodunun tanimli oldugunu gorebiliriz.

public interface Runnable {
	public abstract void run();
}
Runnable arabirimini uygulayarak , “is parcacigi”/thread tanimlama ozelligine sahip olabiliriz.

public class CoolRunnable implements Runnable {

	@Override
	public void run() {
		System.out.println("The job is starting!");
	}

}
Instantiating a Thread( Thread sinifindan bir ornek oluturmak)
Her is parcaciginin(thread) baslangici icin Thread objesi/ornegi gereklidir.
Ister Thread sinifini kalitalim , ister Runnable arabirimini uygulayalim fark etmez yine de
Thread sinifinin ornegine/objesine ihtiyacimiz vardir.

Eger Thread sinifini kalittiysak bu durumda ilgili siniftan bir instance/ornek/obje olusturmamiz yeterli olacaktir.

CoolThread t = new CoolThread();
Eger Runnable arabirimini uyguladiysak , bu durumda hala Thread sinifi ornegine/instance ihtiyacimiz vardir.
Thread sinifini isci(worker) .Runnable arabirimini is(job) olarak dusunebiliriz. Birisi bizim isimizi (job) yapmalidir.
Thread sinifinda Runnable parametre alan bir yapilandirici mevcuttur. Runnable arabirimini uygulayan siniflarin orneklerini/objelerini bu yapilandiriciya 
arguman olarak gecebiliriz.

		
CoolRunnable coolRunnable = new CoolRunnable();
Thread t = new Thread(coolRunnable);
Thread t2 = new Thread(coolRunnable);
Thread t3 = new Thread(coolRunnable);
Burada oldugu gibi birden fazla java.lang.Thread yapilandiricisina ayni CoolRunnable objesini vermemizin anlami ayni is uzerinde(job) uzerinde birden fazla isci(worker) 
calisabilir anlamina gelmektedir.

Thread sinifinin kendisi Runnable’dir. Bunun anlami Runnable tipinde parametre alan yapilandiriciya ,Thread tipinde bir arguman gecebiliriz.
Bu legal bir durumdur fakat kotu bir yaklasimdir bir geregi yoktur.

Thread t2 = new Thread(new CoolThread());
Buraya kadar yeni bir Thread objesi olusturmaktan bahsettik. calisan bir “is parcacigi” kavramindan henuz bahsetmedik.
Thread’ler farkli state/durumlarda bulunabilir. Bunlardan ilerleyen bolumlerde bahsedecegiz.

Bir Thread objesi olusturuldugu , durumu/state “new” dir. Bu durumda thread/is parcacigi , “alive/canli” durumda degildir. Ne zaman ki start() metodu cagrilir bu durumda 
“new” durumundan cikar. run() metodu tamamlandigi zaman “dead/olu” duruma gecer.

Bu durumlarin/state kontrolu isAlive() ve getState() metotlari yardimi ile saglanabilir.

Siniflarimizin son hali;

public class CoolThread extends Thread {

	@Override
	public void run() {
		System.out.println("The job is starting!");
	}

	public static void main(String[] args) {
		CoolThread t = new CoolThread();
		Thread t2 = new Thread(new CoolThread());
	}

}

public class CoolRunnable implements Runnable {

	@Override
	public void run() {
		System.out.println("The job is starting!");
	}

	public static void main(String[] args) {
		CoolRunnable coolRunnable = new CoolRunnable();
		Thread t = new Thread(coolRunnable);
		Thread t2 = new Thread(coolRunnable);
		Thread t3 = new Thread(coolRunnable);

	}

}
